# Immutable dict

types.MappingProxyType — это «чисто» неизменяемый (read-only) «вид» на обычный словарь. Представьте, что у вас есть словарь с данными, которым вы хотите поделиться с остальным кодом, но при этом запретить всем его менять. Вот тут и выручает MappingProxyType.

```python
import types

# Исходный словарь
config = {
    'host': 'localhost',
    'port': 5432,
}

# Создаём read-only «обёртку»
config_ro = types.MappingProxyType(config)

print(config_ro['host'])      # localhost
config_ro['user'] = 'admin'   # TypeError: 'mappingproxy' object does not support item assignment
```

**Как это работает?**

* `config_ro` выглядит и ведёт себя как словарь: поддерживает доступ по ключу, итерацию, методы `keys(), items(), values()`.
* Любые попытки изменить — добавить, удалить или обновить ключ — вызовут `TypeError`.
* При этом если вы всё же поменяете исходный `config` (например, `config['timeout']=10`), `config_ro` отразит изменение сразу. Это важно помнить.

**Зачем это нужно?**

* Защита от «нечаянных» правок глобальных или «разделяемых» настроек.
* Явное разделение ответственности: модуль X может только читать, но не портить вашу конфигурацию.
* Будущее кода становится более надёжным: меньше неожиданных «side-effects», проще отлавливать ошибки.

**Ограничения и нюансы**

* Это лишь «тонкая» оболочка: объекты внутри словаря всё ещё могут быть изменяемыми (например, список в качестве значения).
* Нет глубокого «замораживания» — лишь поверхностное.

В итоге, если вы хотите дать «ручки только для чтения» своему словарю, MappingProxyType — лёгкий и встроенный способ это сделать, без сторонних библиотек и сложных паттернов. И да, защити свой словарь от хулиганов — будущее вашего кода скажет вам «спасибо».
